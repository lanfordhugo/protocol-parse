---
paths:
  - "**/*.py"
---

# Python 编码规范

## 通用原则

- **DRY (Don't Repeat Yourself):** 避免代码重复，尽可能提取为函数或模块。
- **KISS (Keep It Simple, Stupid):** 保持代码简单、清晰，避免不必要的复杂性和过度设计。
- **YAGNI (You Ain't Gonna Need It):** 只实现当前需求明确的功能，避免过度工程。
- **代码行数:** 单个文件代码行数原则上不应超过 600 行。过长文件应考虑拆分为更小的模块或类。测试文件行数不受此限制。
- **Python之禅:** 遵循"简单胜过复杂"、"可读性很重要"、"显式胜过隐式"的设计哲学。

## 面向对象设计原则 (SOLID & More)

- **单一职责原则 (SRP):** 一个类应仅有一个引起它变化的原因。
- **开放封闭原则 (OCP):** 对扩展开放，对修改封闭。
- **里氏替换原则 (LSP):** 子类必须能够替换其基类。
- **接口隔离原则 (ISP):** 客户端不应被强迫依赖于它们不使用的方法。
- **依赖倒置原则 (DIP):** 依赖抽象，而不是依赖具体实现。
- **组合优于继承:** 优先使用对象组合而非类继承来实现代码重用和功能扩展。
- **封装变化点:** 识别系统中可能变化的部分并将其封装起来。
- **最少知识原则 (迪米特法则):** 一个对象应当对其他对象有尽可能少的了解。
- **接口与实现分离:** 通过抽象基类或协议定义行为，隐藏具体实现细节。
- **高内聚低耦合:** 模块内部元素紧密相关，模块间依赖最小化。
- **优先不可变对象:** 尽可能使用不可变数据结构和设计模式。

## Python标准规范 (PEP 8 & More)

- **严格遵循PEP 8:** 所有代码必须严格遵循PEP 8编码规范。
- **强制类型提示:** 所有公共函数、方法和类属性必须有类型提示。
- **现代Python特性优先:** f-string、dataclass、上下文管理器、生成器、async/await等。

## 文件规范

- **文件命名:** 模块文件使用小写下划线 (`user_manager.py`)，包目录使用小写 (`mypackage/`)，测试文件以 `test_` 开头。
- **文件头注释:** 所有 `.py` 文件必须包含标准文件头注释：

  ```python
  """
  文件名称: your_module.py
  内容摘要: 模块功能的简要描述
  当前版本: v1.0.0
  作者: 作者姓名
  创建日期: YYYY-MM-DD
  """
  ```

- **导入顺序:** 标准库 → 第三方库 → 本地导入，各组间用空行分隔。
- **模块级常量:** 在导入语句后定义，使用全大写蛇形命名法。

## 命名规范

- **通用约定:**
  - 类名: 帕斯卡命名法 (PascalCase)，例如 `UserManager`
  - 函数名/方法名/变量名: 蛇形命名法 (snake_case)，例如 `get_user_info()`, `user_name`
  - 常量: 全大写蛇形命名法 (UPPER_SNAKE_CASE)，例如 `MAX_CONNECTIONS`
  - 私有属性/方法: 单下划线前缀，例如 `_internal_method()`
  - 特殊方法: 双下划线包围，例如 `__init__()`

- **特定约定:**
  - 包名/模块名: 全小写，可用下划线，例如 `mypackage`, `user_manager.py`
  - 异常类: 以 `Error` 或 `Exception` 结尾，例如 `ValidationError`
  - 测试类/方法: 以 `Test` 和 `test_` 开头，例如 `TestUserManager`, `test_create_user()`

## 代码格式

- **缩进:** 使用4个空格进行缩进，禁止使用Tab字符。
- **行长度:** 单行代码长度不超过88个字符。
- **空行:** 顶级函数和类定义前后用两个空行分隔，类内方法定义用一个空行分隔。
- **空格:** 二元运算符前后、逗号后、冒号后必须有空格。
- **引号:** 优先使用双引号，文档字符串必须使用三重双引号。

## 类型提示规范

- **强制使用类型提示:** 所有公共函数、方法和类属性必须有类型提示。
- **复杂类型定义:** 使用 `TypeAlias` 或 `NewType` 定义复杂类型。

## 函数与方法设计

- **长度限制:** 函数或方法体不应过长，建议不超过50行代码（不含注释和空行）。
- **单一职责:** 每个函数或方法应专注于完成一个明确、单一的功能。
- **参数数量:** 函数参数不宜过多，建议不超过5个。超过时考虑使用数据类或配置对象。
- **返回值:** 明确返回类型，避免返回 `None` 和其他类型的混合。

## 文档字符串规范 (Docstring)

- **文档字符串格式:** 使用Google风格或NumPy风格的文档字符串。
- **必需内容:** 公共接口函数、类、重要方法必须包含功能描述、参数说明、返回值说明和异常说明。

## 注释规范

- **注释语言:** 所有注释必须使用中文。
- **行注释:** 使用 `#` 进行单行注释，解释非显而易见的代码逻辑。
- **复杂逻辑注释:** 对于复杂的算法、业务逻辑，必须添加清晰的注释块说明其设计思路和关键步骤。
- **TODO/FIXME标记:** 使用 `# TODO: 说明待办事项` 或 `# FIXME: 说明待修复问题及原因` 标记未完成或已知问题点。

## 日志规范

- **标准日志库:** 使用Python标准库 `logging` 模块进行日志记录。
- **日志内容:** 所有日志信息必须使用中文，清晰表达事件或状态。
- **日志级别:** 合理使用DEBUG、INFO、WARNING、ERROR、CRITICAL级别。
- **结构化日志:** 对于复杂应用，使用JSON格式的结构化日志。

## 异常处理规范

- **异常类型:** 使用具体的异常类型，避免使用裸露的 `except:`。
- **自定义异常:** 为应用定义特定的异常类，继承自适当的基础异常类。
- **异常链:** 使用 `raise ... from ...` 保留原始异常信息。
- **异常记录:** 异常发生时应记录适当的日志信息。

## 安全编码基本准则

- **输入验证:** 严格验证所有外部输入（函数参数、文件内容、网络数据等），防止注入、溢出等。
- **敏感数据处理:** 避免在代码中硬编码敏感信息，使用环境变量或配置文件，对敏感信息进行加密处理。
- **最小权限原则:** 代码执行应遵循最小权限原则。
- **依赖安全:** 关注第三方库的已知安全漏洞，及时更新。
- **资源管理:** 使用上下文管理器确保资源在不再需要时被正确释放。

## 并发编程指导原则

- **线程安全:** 使用线程安全的数据结构和同步原语（如 `Lock`、`RLock`、`Queue`）防止数据竞争。
- **异步编程:** 优先使用 `asyncio` 进行异步编程，使用 `async/await` 语法。
- **死锁防范:** 使用上下文管理器和超时机制，避免长时间持有锁。
- **资源管理:** 使用 `with` 语句和上下文管理器确保资源正确释放。

## 测试规范

- **测试框架:** 使用 `pytest` 作为主要测试框架。
- **测试覆盖率:** 使用 `pytest-cov` 检查测试覆盖率，目标覆盖率应达到80%以上。
- **测试隔离:** 使用测试夹具（fixtures）和Mock对象隔离外部依赖。
- **参数化测试:** 使用 `pytest.mark.parametrize` 进行参数化测试。

## 性能优化指导

- **性能分析:** 使用 `cProfile` 和 `line_profiler` 进行性能分析。
- **内存优化:** 使用生成器和迭代器减少内存占用，避免一次性加载大量数据。
- **缓存机制:** 使用 `functools.lru_cache` 进行函数结果缓存。

## 推荐工具配置

- **代码格式化:** Black (自动格式化)、isort (导入排序)
- **代码检查:** flake8 (风格检查)、pylint (质量检查)、mypy (类型检查)
- **测试工具:** pytest (测试框架)、pytest-cov (覆盖率)
- **依赖管理:** Poetry (现代依赖管理)、pip-tools (传统方式)
- **预提交钩子:** pre-commit (代码提交前自动检查)

## AI辅助编码提示

- AI在生成或修改Python代码时，必须严格遵循以上所有规范。
- 当AI检测到用户现有代码可能违反上述规范时，应主动提出提示和修改建议。
- 优先使用现代Python特性和最佳实践。
- 始终包含适当的类型提示和文档字符串。
- 考虑代码的可测试性、可维护性和性能。
- 遵循"显式优于隐式"、"简单优于复杂"的Python哲学。
