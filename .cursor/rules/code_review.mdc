---
description: Python项目代码质量检查规则
globs: ["**/*.py"]
alwaysApply: true
---
# AI Python代码质量检查清单 (Code Review)

## 核心审查原则

本文件定义了AI进行Python代码审查时 **必须** 遵循的客观标准和检查清单。

- **核心目标:** 识别潜在缺陷，提升Python代码质量与可维护性，确保代码符合Python社区最佳实践。
- **审查视角:** AI应以一个**严谨的、经验丰富的、注重长期维护性的Python开发者**视角进行审查，重点关注Python特有的代码质量问题。
- **规则来源:** 本文档是所有Python代码评审活动的**唯一**标准来源。所有检查项都必须严格遵守。
- **Python规范:** 严格遵循PEP 8、PEP 257等Python官方编码规范。

---

## AI 代码质量检查清单

AI **必须** 按以下顺序，对每一项进行逐一检查，并对每个问题给出明确的"是/否/不适用"的初步判断，并对"否"的项提供详细解释和改进建议。

### 一、 功能正确性与健壮性

- **A. 核心逻辑实现:**
  - [ ] 代码是否准确实现了需求文档（Issue/PRD）中定义的所有功能？
  - [ ] 所有明确或隐含的业务规则和计算逻辑是否都已正确无误地实现？
  - [ ] 算法实现是否符合Python的惯用法（Pythonic）？
- **B. 边界与异常场景处理:**
  - [ ] 是否充分考虑并正确处理了所有可预见的边界条件（如None、空列表/字典、最大/最小值、0值）？
  - [ ] 是否存在潜在的"差一错误"(off-by-one errors)，特别是在列表/字符串索引操作中？
  - [ ] 是否正确处理了Python特有的边界情况（如空字符串、空容器的布尔值判断）？
- **C. 错误处理机制:**
  - [ ] 是否预见并妥善处理了所有潜在的运行时错误和失败路径？
  - [ ] 资源清理（如文件句柄、网络连接、数据库连接）是否在所有代码路径都得到了保证？
  - [ ] Python异常处理是否完善，是否使用了适当的异常类型（内置异常vs自定义异常）？
  - [ ] 是否避免了裸露的except子句，是否捕获了具体的异常类型？
  - [ ] 是否正确使用了try-except-else-finally结构？
- **D. 输入有效性验证:**
  - [ ] 是否对所有外部来源的输入（函数参数、文件数据、网络数据等）进行了严格的有效性验证？
  - [ ] 是否使用了类型注解来明确参数和返回值类型？
  - [ ] 是否在函数开始处进行了参数验证（防御性编程）？

---

### 二、 效率与性能

- **A. 算法与数据结构:**
  - [ ] 所选算法和数据结构是否高效，是否存在明显更优的选择（时间/空间复杂度）？
  - [ ] 是否使用了Python内置的高效数据结构（list、dict、set、tuple）而非自定义实现？
  - [ ] 是否合理使用了collections模块的专用数据结构（deque、defaultdict、Counter等）？
- **B. 资源管理:**
  - [ ] 内存使用是否高效？是否存在内存泄漏风险（如循环引用、大对象未及时释放）？
  - [ ] 是否正确使用了上下文管理器（with语句）来管理资源？
  - [ ] 文件、网络连接、数据库连接等资源是否被及时、正确地释放？
  - [ ] 是否避免了不必要的对象创建和大对象的深拷贝？
- **C. 潜在性能瓶颈:**
  - [ ] 是否存在明显的性能热点，如循环内的昂贵操作、不必要的重复计算？
  - [ ] 是否避免了在循环中进行字符串拼接（应使用join()或f-string）？
  - [ ] 是否合理使用了生成器表达式和列表推导式来提高性能？
  - [ ] 是否避免了频繁的类型转换和不必要的函数调用？
  - [ ] 对于大数据处理，是否考虑使用numpy、pandas等专业库？

---

### 三、 安全性

- **A. 输入处理与输出编码:**
  - [ ] 是否对所有不可信输入进行了充分的清理和验证，以防止注入类攻击？
  - [ ] 是否避免了使用eval()、exec()等危险函数，或确保输入已充分验证？
  - [ ] 文件路径操作是否防范了路径遍历攻击（使用os.path.join()、pathlib等）？
- **B. 敏感数据保护:**
  - [ ] 代码中是否避免了硬编码敏感信息（如密码、API密钥、数据库连接字符串）？
  - [ ] 是否使用了环境变量或配置文件来管理敏感信息？
  - [ ] 敏感数据在日志或存储中是否得到了适当的保护（如脱敏、加密）？
  - [ ] 是否避免了在异常信息中泄露敏感数据？
- **C. 依赖与API安全:**
  - [ ] 使用的第三方库是否来自可信源（PyPI官方）？
  - [ ] 是否定期检查依赖库的安全漏洞（使用safety、bandit等工具）？
  - [ ] requirements.txt中是否固定了依赖版本以避免供应链攻击？
- **D. 安全的错误处理:**
  - [ ] 错误信息是否避免了泄露可能被攻击者利用的系统内部细节？
  - [ ] 是否避免了在生产环境中显示详细的堆栈跟踪信息？

---

### 四、 并发与同步 (若适用)

- **A. 线程安全:**
  - [ ] 共享资源的访问是否通过适当的同步机制（如threading.Lock、threading.RLock）进行了保护？
  - [ ] 是否正确理解了Python的GIL（全局解释器锁）对多线程的影响？
  - [ ] 对于CPU密集型任务，是否考虑使用multiprocessing而非threading？
- **B. 锁的使用:**
  - [ ] 锁的粒度是否合适？是否存在潜在的死锁风险？
  - [ ] 锁的持有时间是否已最小化？
  - [ ] 是否使用了上下文管理器（with语句）来确保锁的正确释放？
- **C. 异步编程 (若使用asyncio):**
  - [ ] 是否正确使用了async/await语法？
  - [ ] 是否避免了在异步函数中使用阻塞操作？
  - [ ] 是否正确处理了异步异常和取消操作？

---

### 五、 设计质量与原则符合性

- **A. 需求与设计符合度:**
  - [ ] 实现是否严格遵循了相关设计文档中定义的高层架构、组件职责和接口契约？
  - [ ] 是否遵循了Python的设计哲学（The Zen of Python）？
- **B. SOLID原则:**
  - [ ] 类和函数是否遵循了单一职责原则？
  - [ ] 设计是否对扩展开放、对修改关闭（开闭原则）？
  - [ ] 是否正确使用了继承和组合？
  - [ ] 接口是否遵循了接口隔离原则？
- **C. 模块化与耦合度:**
  - [ ] 模块/类是否具有高内聚、低耦合的特性？
  - [ ] 依赖关系是否清晰、合理，是否朝向抽象而非具体实现？
  - [ ] 是否合理使用了Python的包和模块结构？
  - [ ] 是否避免了循环导入？
- **D. 接口设计 (API Design):**
  - [ ] 公共接口是否设计得清晰、易于理解和使用？
  - [ ] 是否不必要地暴露了内部实现细节（使用_前缀标识私有成员）？
  - [ ] 函数签名是否简洁明了，参数数量是否合理？
  - [ ] 是否提供了合适的默认参数值？

---

### 六、 编码标准与风格符合性

- **A. PEP 8规范符合性:**
  - [ ] 代码是否 **完全** 遵循了PEP 8编码规范（缩进、行长度、空行、导入顺序等）？
  - [ ] 命名是否遵循Python约定（snake_case用于变量和函数，PascalCase用于类）？
  - [ ] 是否正确使用了空格和换行来提高可读性？
- **B. 文档字符串规范:**
  - [ ] 是否遵循了PEP 257文档字符串约定？
  - [ ] 所有公共函数、类、模块是否都有适当的文档字符串？
  - [ ] 文档字符串是否包含了参数、返回值、异常的说明？
- **C. 类型注解:**
  - [ ] 是否使用了类型注解来提高代码可读性和IDE支持？
  - [ ] 类型注解是否准确、完整？
  - [ ] 是否遵循了PEP 484类型注解规范？

---

### 七、 可读性与可维护性

- **A. 代码清晰度:**
  - [ ] 代码逻辑是否直观易懂，是否避免了不必要的复杂性或过度技巧性写法？
  - [ ] 是否遵循了"代码应该像散文一样易读"的Python哲学？
  - [ ] 复杂逻辑是否被分解为小的、易理解的函数？
- **B. 命名表达力:**
  - [ ] 变量、函数、类等的名称是否准确表达了其意图和用途？
  - [ ] 是否避免了缩写和模糊的命名？
  - [ ] 布尔变量是否使用了is_、has_、can_等前缀？
- **C. 注释质量:**
  - [ ] 注释是否清晰地解释了"为什么这么做"，而不仅仅是"做了什么"？
  - [ ] 复杂算法是否有充分的注释说明？
  - [ ] 是否避免了过时或误导性的注释？
- **D. 消除重复与硬编码 (DRY):**
  - [ ] 是否存在可以提取为公共函数或常量的重复代码块？
  - [ ] 是否避免了魔法数字和硬编码字符串？
  - [ ] 配置信息是否集中管理？

---

### 八、 可测试性

- **A. 函数设计:**
  - [ ] 函数是否设计为纯函数（无副作用），便于测试？
  - [ ] 外部依赖（IO、网络、数据库）是否通过参数传入或依赖注入？
  - [ ] 是否避免了在函数内部直接访问全局变量？
- **B. 独立性与隔离性:**
  - [ ] 类和方法是否易于进行单元测试，能否在不依赖过多外部组件的情况下独立验证？
  - [ ] 是否避免了使用难以测试的静态方法和全局状态？
  - [ ] 是否提供了合适的mock点来隔离外部依赖？
- **C. 测试友好设计:**
  - [ ] 是否使用了合适的设计模式（如策略模式、工厂模式）来提高可测试性？
  - [ ] 复杂的类是否提供了测试所需的内部状态访问方法？
  - [ ] 是否避免了在构造函数中执行复杂的初始化逻辑？
