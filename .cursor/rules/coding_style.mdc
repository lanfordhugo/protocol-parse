---
description: 
globs: 
alwaysApply: false
---
# 代码风格规则

## 通用原则

- **DRY (Don't Repeat Yourself):** 避免代码重复，尽可能提取为函数或模块。
- **KISS (Keep It Simple, Stupid):** 保持代码简单、清晰，避免不必要的复杂性和过度设计。
- **YAGNI (You Ain't Gonna Need It):** 只实现当前需求明确的功能，避免过度工程。
- **代码行数:** 单个文件代码行数原则上不应超过 600 行。过长文件应考虑拆分为更小的模块或类。测试文件行数不受此限制。

## 面向对象设计原则 (SOLID & More)

- **单一职责原则 (SRP):** 一个类应仅有一个引起它变化的原因。
- **开放封闭原则 (OCP):** 对扩展开放，对修改封闭。
- **里氏替换原则 (LSP):** 子类必须能够替换其基类。
- **接口隔离原则 (ISP):** 客户端不应被强迫依赖于它们不使用的方法。
- **依赖倒置原则 (DIP):** 依赖抽象，而不是依赖具体实现。
- **组合优于继承:** 优先使用对象组合而非类继承来实现代码重用和功能扩展。
- **封装变化点:** 识别系统中可能变化的部分并将其封装起来。
- **最少知识原则 (迪米特法则):** 一个对象应当对其他对象有尽可能少的了解。
- **接口与实现分离:** 通过接口定义行为，隐藏具体实现细节。
- **高内聚低耦合:** 模块内部元素紧密相关，模块间依赖最小化。
- **优先不可变对象:** 尽可能设计和使用不可变对象。

## C++标准规范 (C++11)

- **严格遵循C++11:** 所有代码必须严格遵循C++11标准，不得使用更高版本（如C++14/17/20）的特性。
- **编译器标志:** 编译时必须使用 `-std=c++11` 标志确保合规性。
- **C++11常用特性列表:**
  - 类型推导: `auto`
  - 基于范围的for循环: `for (auto& item : container)`
  - Lambda表达式
  - 智能指针: `std::shared_ptr`, `std::unique_ptr`
  - 右值引用与移动语义
  - 空指针: `nullptr` (替代 `NULL`)
  - 强类型枚举: `enum class` (替代普通 `enum`)

## 文件规范 (V8MCU C++)

- **文件命名:** 头文件使用 `.h` 后缀，源文件使用 `.cpp` 后缀。文件名采用帕斯卡命名法 (PascalCase)，例如 `MyClass.h`。
- **文件头注释:** 所有 `.h` 和 `.cpp` 文件必须包含标准文件头注释：

  ```cpp
  /***************************************************************************
   * 版权所有: Copyright (C) 2025
   * 文件名称: YourFileName.h / YourFileName.cpp
   * 内容摘要: 
   * 当前版本: V1.0
   * 作   者: 
   * 完成日期: YYYY-MM-DD
   **************************************************************************/
  ```

- **头文件保护 (Include Guards):** 所有头文件必须使用 `#ifndef` / `#define` / `#endif` 防止重复包含。

  ```cpp
  #ifndef MY_MODULE_MY_CLASS_H
  #define MY_MODULE_MY_CLASS_H
  // ... class definition ...
  #endif // MY_MODULE_MY_CLASS_H
  ```

- **包含顺序 (Include Order):**
  1. 对应的头文件 (仅在 `.cpp` 文件中, 例如 `MyClass.cpp` 首先包含 `MyClass.h`)
  2. C 系统头文件 (例如 `<stdio.h>`)
  3. C++ 标准库头文件 (例如 `<vector>`, `<string>`)
  4. 第三方库头文件 (例如 `erpc/erpc_client_setup.h`)
  5. 本项目其他模块的公共头文件 (例如 `common_types.h`)
  6. 本项目内部头文件 (例如同模块下的其他头文件)
- **头文件引用风格:**
  - **公共组件头文件:** 指项目中的公共/基础模块提供的头文件 (通常位于 `com/include`, `base/include` 等)。**必须**使用不含路径的直接包含风格，例如 `#include "easyLog.h"` 。
  - **模块内部/特定头文件:** 指特定模块内部实现相关的头文件。**必须**使用带模块路径的包含风格，例如 `#include "network_monitor/include/NetworkMonitorTypes.h"`。
  - **禁止行为:** 严禁使用相对父目录 (`../`) 或绝对路径进行包含。

## 命名规范

- **通用约定:**
  - 类名/结构体名/枚举类型名: 帕斯卡命名法 (PascalCase)，例如 `MyClass`, `EStatusCode`。
  - 函数名/方法名: 驼峰命名法 (camelCase)，例如 `getUserName()`。
  - 变量名 (局部变量、参数): 驼峰命名法 (camelCase)，例如 `userName`。
  - 常量 (编译期常量, `enum`值): 全大写蛇形命名法 (UPPER_SNAKE_CASE)，例如 `MAX_CONNECTIONS`, `STATUS_OK`。
- **V8MCU C++ 特定前缀/后缀:**
  - 类名: `C` 前缀，例如 `CConfigManager`。
  - 接口类名: `I` 前缀，例如 `ILogger`。
  - 成员变量 (非静态): 下划线后缀，例如 `count_`。
  - 指针变量: `p` 前缀 (可选，若类型已明确表明指针则可省略)，例如 `pUserConfig_`。
  - 静态成员变量: `s_` 前缀，例如 `s_instance_`。
  - 全局变量: `g_` 前缀 (应尽可能避免使用全局变量)，例如 `g_systemStatus_`。
  - 枚举类型名: `E` 前缀，例如 `EParseResult`。
  - 函数名: 通常以动词或动词短语开头，清晰表达其行为。

## 代码格式

- **缩进:** 使用4个空格进行缩进，禁止使用Tab字符。
- **空格:**
  - 二元/三元运算符前后必须有空格。
  - 逗号后必须有空格。
  - 控制语句关键字后 (如 `if`, `for`, `while`) 和左括号之间必须有空格。
  - 函数名和参数列表的左括号之间通常无空格 (模板或宏定义可能例外)。
  - 括号内侧 (圆括号、方括号) 通常无额外空格。
- **行长度:** 单行代码长度原则上不超过120个字符。
- **大括号 ({}) 位置:**
  - 函数定义、类/结构体/枚举定义、命名空间定义：左大括号另起一行。

    ```cpp
    void CMyClass::myMethod()
    {
        // ...
    }
    ```

  - 控制语句 (`if`, `else`, `for`, `while`, `do...while`, `switch`)：左大括号另起一行。

    ```cpp
    if (condition)
    {
        // ...
    }
    else
    {
        // ...
    }
    ```

  - 单行语句块也必须使用大括号。
- **函数参数换行:** 若函数声明或调用参数过多导致行超长，参数应垂直对齐，每个参数占一行。

  ```cpp
  void processData(const std::string& inputPath,
                   std::vector<ResultType>& outputResults,
                   const ConfigOptions& options,
                   bool enableLogging);
  ```

## 函数与方法设计

- **长度限制:** 函数或方法体不应过长，建议不超过50行代码 (不含注释和空行)。
- **单一职责:** 每个函数或方法应专注于完成一个明确、单一的功能。
- **参数数量:** 函数参数不宜过多，建议不超过4个。
- **参数传递:**
  - 对于大型对象或只读对象，优先使用 `const T&` 传递以避免拷贝开销。
  - 对于需要修改的非基本类型参数，可使用指针 `T*` 或引用 `T&`。
  - 明确出参使用指针或引用，并在Doxygen注释中清晰标注。

## 注释规范

- **注释语言:** 所有注释和日志打印信息必须使用中文。
- **Doxygen风格函数注释:** 公共接口函数、类、重要成员变量等必须使用Doxygen兼容格式进行注释。

  ```cpp
  /**
   * @brief 函数/方法功能简述。
   * @param paramName 参数说明。
   * @param[out] outParamName 出参说明 (若有)。
   * @return ReturnType 返回值说明。
   * @note 可选的注意事项或实现细节说明。
   * @see 相关函数或文档链接。
   */
  ReturnType functionName(Type paramName);
  ```

- **行注释:** 使用 `//` 进行单行或行尾注释，解释非显而易见的代码逻辑。
- **复杂逻辑注释:** 对于复杂的算法、业务逻辑或状态转换，必须添加清晰的注释块说明其设计思路和关键步骤。
- **TODO/FIXME:** 使用 `// TODO: 说明待办事项` 或 `// FIXME: 说明待修复问题及原因` 标记未完成或已知问题点。

## 日志规范

- **标准日志接口:** 使用项目提供的宏 (如 `MsgError(...)`, `MsgInfo(...)`, `MsgDebug(...)`) 进行日志记录。
- **日志内容:** 所有日志信息必须使用中文，清晰表达事件或状态。
- **数据日志接口:** 使用项目提供的宏 (如 `MsgData(...)`, `MsgDataMem(...)`) 记录结构化数据或通信报文。
- **`UNIT_TEST_MODE_LOG` 宏:**
  - 单元测试构建时应定义 `UNIT_TEST_MODE_LOG` 宏 (通常在Makefile中通过 `-DUNIT_TEST_MODE_LOG` 实现)。
  - 定义此宏后，标准日志宏将重定向到轻量级日志实现 (`easyLog.h`)，数据日志宏将变为空操作，以简化测试并加速编译。

## 错误码处理 (Error Code Handling)

- **标准错误码:** 项目中所有错误码的定义和使用，**必须**参照 `com/define/std_def.h` 文件中的 `EErrorCode` 枚举。
- **优先使用标准枚举:** 优先使用 `EErrorCode` 类型表示和处理错误状态。
- **避免自定义错误码:** 除非有充分理由并通过评审，否则禁止在模块或类中定义与 `std_def.h` 重复或冲突的本地错误码。
- **错误返回:** 函数执行发生错误时，应返回相应的 `EErrorCode` 值。对于可能不抛出异常的函数，返回值是主要的错误传递方式。

## 安全编码基本准则

- **输入验证:** 严格验证所有外部输入（函数参数、文件内容、网络数据等），防止注入、溢出等。
- **敏感数据处理:**
  - 避免在代码中硬编码敏感信息（密码、密钥等）。
  - 存储、传输、记录日志时，对敏感信息进行必要的加密或脱敏处理。
- **最小权限原则:** 代码执行应遵循最小权限原则。
- **依赖安全:** 关注第三方库的已知安全漏洞，及时更新。
- **安全错误信息:** 避免在错误信息中泄露过多系统内部细节。
- **资源管理:** 使用RAII或类似机制确保资源（内存、文件、锁等）在不再需要时被正确释放，尤其是在异常路径中。

## 并发编程指导原则 (若适用)

- **共享资源保护:** 访问共享数据必须使用同步机制（如 `std::mutex`, `std::atomic`, `std::condition_variable`）防止数据竞争。
- **死锁防范:** 设计锁策略时注意锁的获取顺序，避免循环等待。考虑使用 `std::lock` (C++11) 或 `std::scoped_lock` (C++17, 思想可借鉴) 管理多个锁。
- **锁的粒度与持有时间:** 合理设计锁的粒度，最小化锁的持有时间。
- **线程安全设计:** 明确类和函数的线程安全保证。优先设计不可变对象或无状态组件。
- **避免在锁内执行耗时操作:** 不要在持有锁的关键区段执行可能阻塞或耗时过长的操作（如IO、复杂计算、回调外部未知代码）。

## 可测试性设计

- **依赖隔离与注入:**
  - 外部依赖（IO、网络、硬件、其他复杂组件）应通过接口抽象。
  - 优先使用构造函数注入或Setter方法注入依赖的接口实例，便于测试时替换为Mock或Stub对象。
  - 依赖声明为接口类型 (`I`前缀)，避免直接依赖具体实现类。
- **避免测试障碍:**
  - 限制使用静态方法和全局状态，它们会增加测试隔离的难度。
  - 避免过于复杂的继承链和过多的 `private` 方法使得状态难以验证。
  - 避免在业务逻辑中直接使用不确定性函数 (如 `time()`, `rand()`) 或硬编码路径，应将其抽象或注入。
- **接口可验证性:** 设计公共接口时，应使其返回结果或对象状态易于在测试中进行验证。
- **错误传递与状态:** 使用返回码 (`EErrorCode`) 或明确的异常（若项目规范允许）传递错误，定义清晰的错误状态供测试验证。

## AI辅助编码提示

- AI在生成或修改C++代码时，必须严格遵循以上所有规范。
- 当AI检测到用户现有代码可能违反上述规范时，应主动提出提示和修改建议。
