# ==================================================================================
# V8Parse 协议配置模板 - 新手完全指南
# ==================================================================================
# 
# 🎯 这个文件是什么？
# 这是一个协议配置模板，用于向 V8Parse 工具说明如何解析特定通信协议的数据包。
# 就像给翻译官一本字典，告诉他怎么把二进制数据翻译成人类能读懂的文字。
#
# 🚀 如何使用？
# 1. 复制这个文件到：configs/<你的协议名>/protocol.yaml
# 2. 根据你的协议文档修改配置内容
# 3. 运行：python main.py <你的协议名>
#
# 💡 配置原理：
# 通信设备之间传输的都是16进制数据（如：AA F5 01 02 03），我们需要告诉工具：
# - 哪些字节表示什么意思（如：第1-2字节是帧头，第3字节是命令码）
# - 怎么把数字转换成有意义的文字（如：数值1表示"在线"，0表示"离线"）
# - 如何处理重复的数据结构（如：多个传感器数据）
#
# ==================================================================================

# ==================================================================================
# 第一部分：协议基本信息 (meta)
# ==================================================================================
# 这里定义协议的基本属性，相当于协议的"身份证"
meta:
  protocol: example_protocol      # 协议名称，必须与目录名一致
  version: 1                     # 配置文件版本号，用于版本管理
  default_endian: LE             # 默认字节序: LE(小端字节序) 或 BE(大端字节序)
  notes: 这是一个协议配置示例      # 协议说明，可以写任何有助于理解的信息

# ⚠️ 什么是字节序？
# 假设有一个16位数字 0x1234：
# - 大端(BE): 高字节在前 → [0x12, 0x34]
# - 小端(LE): 低字节在前 → [0x34, 0x12]
# 大部分工业协议使用小端字节序(LE)

# ==================================================================================
# 第二部分：协议兼容性配置 (compatibility)
# ==================================================================================
# 这里定义协议的基本格式，告诉工具如何识别和分割数据包
compatibility:
  head_len: 11                   # 报文头长度（字节数）
  tail_len: 2                    # 报文尾长度（字节数）
  frame_head: "AA F5"           # 帧头标识（16进制字符串，用空格分隔）
  
  # 头部字段定义 - 从报文头中提取关键信息
  head_fields:
    - {name: "cmd", offset: 4, length: 2, endian: "little", type: "uint"}      # 命令码
    - {name: "index", offset: 6, length: 2, endian: "little", type: "uint"}    # 流水号
    - {name: "deviceType", offset: 8, length: 1, endian: "little", type: "uint"} # 设备类型
    - {name: "addr", offset: 9, length: 1, endian: "little", type: "uint"}     # 设备地址
    - {name: "gunNum", offset: 10, length: 1, endian: "little", type: "uint"}  # 枪号

# 💡 报文结构示例：
# [帧头11字节] + [数据体N字节] + [校验尾2字节]
# 帧头格式：AA F5 [长度2字节] [命令2字节] [流水号2字节] [设备类型1字节] [地址1字节] [枪号1字节]

# ⚠️ head_fields 支持的 type 类型：
# - "uint": 无符号整数（最常用）
# - "hex": 16进制显示
# - "const": 常量校验，需配合 const_value 使用，用于校验固定值
#
# 💡 常量校验示例（用于校验帧头固定值）：
# head_fields:
#   - {name: "startField", offset: 0, length: 2, endian: "big", type: "const", const_value: 0x7dd0}

# ==================================================================================
# 第三部分：数据类型定义 (types)
# ==================================================================================
# 定义所有可能用到的数据类型，相当于数据解析的"工具箱"
types:
  # --------------------------------------------------------------------------------
  # 基础整数类型 - 用于数值数据
  # --------------------------------------------------------------------------------
  uint8:   { base: uint, bytes: 1, signed: false }    # 无符号8位整数 (0-255)
  uint16:  { base: uint, bytes: 2, signed: false }    # 无符号16位整数 (0-65535)
  uint32:  { base: uint, bytes: 4, signed: false }    # 无符号32位整数 (0-4294967295)
  int8:    { base: int,  bytes: 1, signed: true }     # 有符号8位整数 (-128到127)
  int16:   { base: int,  bytes: 2, signed: true }     # 有符号16位整数 (-32768到32767)
  int32:   { base: int,  bytes: 4, signed: true }     # 有符号32位整数
  
  # --------------------------------------------------------------------------------
  # 字符串类型 - 用于文本数据
  # --------------------------------------------------------------------------------
  ascii:   { base: str,  encoding: ASCII }            # ASCII字符串
  utf8:    { base: str,  encoding: UTF8 }             # UTF-8字符串
  
  # --------------------------------------------------------------------------------
  # 特殊显示类型
  # --------------------------------------------------------------------------------
  hex:     { base: hex }                              # 16进制显示（保持原始hex格式）
  
  # --------------------------------------------------------------------------------
  # BCD码类型 - 用于压缩十进制数据
  # --------------------------------------------------------------------------------
  # BCD码：用4位二进制表示1位十进制数字
  # 例如：0x12 表示十进制数 12，0x1234 表示十进制数 1234
  bcd1:    { base: bcd, bytes: 1 }                   # 1字节BCD码 (最多2位十进制数)
  bcd2:    { base: bcd, bytes: 2 }                   # 2字节BCD码 (最多4位十进制数)
  bcd3:    { base: bcd, bytes: 3 }                   # 3字节BCD码 (最多6位十进制数)
  bcd4:    { base: bcd, bytes: 4 }                   # 4字节BCD码 (最多8位十进制数)
  bcd6:    { base: bcd, bytes: 6 }                   # 6字节BCD码 (最多12位十进制数)
  bcd7:    { base: bcd, bytes: 7 }                   # 7字节BCD码 (最多14位十进制数，常用于桩编码)
  bcd10:   { base: bcd, bytes: 10 }                  # 10字节BCD码 (最多20位十进制数，常用于SIM卡号)
  bcd16:   { base: bcd, bytes: 16 }                  # 16字节BCD码 (最多32位十进制数，常用于交易流水号)
  
  # --------------------------------------------------------------------------------
  # 时间类型 - 用于时间戳数据
  # --------------------------------------------------------------------------------
  cp56time2a: { base: time.cp56time2a, bytes: 7 }    # IEC104标准时间格式(7字节)
  
  # 💡 IEC104时间格式说明：
  # 字节0-1: 毫秒 (0-59999)
  # 字节2: 分钟 (0-59) 
  # 字节3: 小时 (0-23)
  # 字节4: 日 (1-31)
  # 字节5: 月 (1-12)
  # 字节6: 年 (相对于2000年)
  
  # --------------------------------------------------------------------------------
  # 二进制字符串类型 - 用于原始数据显示
  # --------------------------------------------------------------------------------
  binary_str_1byte:  { base: binary_str, bytes: 1 }  # 1字节二进制字符串
  binary_str_2bytes: { base: binary_str, bytes: 2 }  # 2字节二进制字符串
  binary_str_4bytes: { base: binary_str, bytes: 4 }  # 4字节二进制字符串
  binary_str_8bytes: { base: binary_str, bytes: 8 }  # 8字节二进制字符串
  
  # --------------------------------------------------------------------------------
  # 位字段类型 - 用于精确的位级数据解析
  # --------------------------------------------------------------------------------
  # bitfield 提供比 bitset 更精确的位控制，支持任意位宽和位置
  bitfield8:  { base: bitfield, bytes: 1, order: lsb0 }   # 8位位字段
  bitfield16: { base: bitfield, bytes: 2, order: lsb0 }   # 16位位字段  
  bitfield32: { base: bitfield, bytes: 4, order: lsb0 }   # 32位位字段
  bitfield64: { base: bitfield, bytes: 8, order: lsb0 }   # 64位位字段（用于大量设备状态位）
  
  # 💡 bitfield vs bitset 区别：
  # - bitset: 每个位独立解析，适用于开关状态
  # - bitfield: 支持多位组合，适用于数值、枚举、复杂状态
  
  # --------------------------------------------------------------------------------
  # 位集合类型 - 用于状态位解析
  # --------------------------------------------------------------------------------
  # 将一个字节的8个位分别解析为不同的状态
  device_status_bits:
    base: bitset
    bits:
      - {name: "设备在线状态"}      # 位0：0=离线，1=在线
      - {name: "充电状态"}         # 位1：0=未充电，1=正在充电
      - {name: "故障状态"}         # 位2：0=正常，1=故障
      - {name: "门锁状态"}         # 位3：0=未锁，1=已锁
      - {name: "急停状态"}         # 位4：0=正常，1=急停
      - {name: "预留位5"}          # 位5：预留
      - {name: "预留位6"}          # 位6：预留
      - {name: "预留位7"}          # 位7：预留
  
  # 16位状态位示例
  alarm_status_bits:
    base: bitset
    bits:
      - {name: "过压告警"}         # 位0
      - {name: "欠压告警"}         # 位1
      - {name: "过流告警"}         # 位2
      - {name: "过温告警"}         # 位3
      - {name: "通信故障"}         # 位4
      - {name: "接触器故障"}       # 位5
      - {name: "绝缘故障"}         # 位6
      - {name: "漏电故障"}         # 位7
      - {name: "风扇故障"}         # 位8
      - {name: "输入故障"}         # 位9
      - {name: "预留位10"}         # 位10
      - {name: "预留位11"}         # 位11
      - {name: "预留位12"}         # 位12
      - {name: "预留位13"}         # 位13
      - {name: "预留位14"}         # 位14
      - {name: "预留位15"}         # 位15

# ==================================================================================
# 第四部分：枚举定义 (enums)
# ==================================================================================
# 将数字值映射为有意义的文字，让数据更容易理解
enums:
  # 执行结果枚举
  result_code:
    0: 失败
    1: 成功
    2: 超时
    3: 参数错误
    255: 未知错误
  
  # 设备状态枚举
  device_status:
    0: 离线
    1: 在线
    2: 故障
    3: 维护中
    4: 升级中
  
  # 充电状态枚举
  charge_status:
    0: 空闲
    1: 准备充电
    2: 正在充电
    3: 充电完成
    4: 充电暂停
    5: 充电异常
  
  # 支付状态枚举
  payment_status:
    0: 未支付
    1: 支付中
    2: 支付成功
    3: 支付失败
    4: 退款中
    5: 退款成功
  
  # 枪状态枚举
  gun_status:
    0: 枪未连接
    1: 枪已连接
    2: 枪锁定
    3: 枪故障
  
  # 设备模式枚举 - 用于bitfield位组
  device_mode:
    0: 待机模式
    1: 工作模式
    2: 维护模式
    3: 故障模式
  
  # 告警级别枚举 - 用于bitfield位组
  alarm_level:
    0: 正常
    1: 警告
    2: 严重
    3: 危险

# ==================================================================================
# 第五部分：命令定义 (cmds)
# ==================================================================================
# 这是最重要的部分！定义每个命令的数据结构
# 每个命令号对应一种报文格式，告诉工具如何解析数据体部分

cmds:
  # --------------------------------------------------------------------------------
  # 命令1：设备基本信息查询 - 最简单的固定字段示例
  # --------------------------------------------------------------------------------
  1:
    - {len: 1, name: 设备类型, type: uint8}                               # 1字节设备类型
    - {len: 2, name: 设备ID, type: uint16}                                # 2字节设备ID
    - {len: 4, name: 设备序列号, type: uint32}                            # 4字节序列号
    - {len: 1, name: 设备状态, type: uint8, enum: device_status}          # 1字节状态(使用枚举)
    - {len: 32, name: 设备名称, type: ascii}                              # 32字节ASCII设备名
    - {len: 16, name: 软件版本, type: ascii}                              # 16字节软件版本
    - {len: 16, name: 硬件版本, type: ascii}                              # 16字节硬件版本
  
  # 💡 解析结果示例：
  # 原始数据：01 00 01 00 00 00 01 01 43 68 61 72 67 65 72 2D 30 30 31 00 00...
  # 解析结果：
  # - 设备类型: 1
  # - 设备ID: 1  
  # - 设备序列号: 1
  # - 设备状态: 在线
  # - 设备名称: "Charger-001"
  # - 软件版本: "V1.0.0"
  # - 硬件版本: "H1.0.0"
  
  # --------------------------------------------------------------------------------
  # 命令2：实时数据上传 - 带缩放因子的数值处理示例
  # --------------------------------------------------------------------------------
  2:
    - {len: 2, name: 电压值, type: uint16, scale: 0.1, unit: V}           # 实际电压 = 原始值 × 0.1
    - {len: 2, name: 电流值, type: uint16, scale: 0.01, unit: A}          # 实际电流 = 原始值 × 0.01
    - {len: 2, name: 功率值, type: uint16, scale: 0.1, unit: kW}          # 实际功率 = 原始值 × 0.1
    - {len: 1, name: 温度值, type: uint8, scale: 1, offset: -40, unit: ℃} # 实际温度 = 原始值 - 40
    - {len: 2, name: SOC值, type: uint16, scale: 0.1, unit: "%"}          # SOC百分比
    - {len: 1, name: 充电状态, type: uint8, enum: charge_status}           # 充电状态枚举
  
  # 💡 缩放因子说明：
  # scale: 缩放系数，实际值 = 原始值 × scale
  # offset: 偏移量，实际值 = 原始值 + offset  
  # unit: 单位，仅用于显示
  #
  # 例如：原始值 2350，scale=0.1，unit=V → 显示为 "235.0V"
  
  # --------------------------------------------------------------------------------
  # 命令3：命令执行响应 - 枚举使用示例
  # --------------------------------------------------------------------------------
  3:
    - {len: 1, name: 执行结果, type: uint8, enum: result_code}            # 使用result_code枚举
    - {len: 2, name: 错误码, type: uint16}                                # 具体错误代码
    - {len: 32, name: 错误描述, type: ascii}                              # 错误详细描述
    - {len: 4, name: 执行时间戳, type: uint32}                            # Unix时间戳
  
  # --------------------------------------------------------------------------------
  # 命令10：多枪状态上传 - 变长循环示例
  # --------------------------------------------------------------------------------
  # 这个命令用于上传多个充电枪的状态，枪的数量是动态的
  10:
    - {len: 1, name: 充电枪数量, type: uint8, id: gun_count}             # 记录枪数量，id用于后续引用
    - {len: 4, name: 时间戳, type: uint32}                               # 数据采集时间
    # 按gun_count的值循环解析后续数据
    - repeat_by: gun_count                                               # 变长循环：按gun_count字段值循环
      fields:
        - {len: 1, name: 枪号, type: uint8}                              # 每个枪的编号
        - {len: 1, name: 枪状态, type: uint8, enum: gun_status}          # 枪状态
        - {len: 2, name: 输出电压, type: uint16, scale: 0.1, unit: V}     # 当前输出电压
        - {len: 2, name: 输出电流, type: uint16, scale: 0.01, unit: A}    # 当前输出电流
        - {len: 1, name: 故障码, type: uint8}                            # 故障代码
  
  # 💡 变长循环解析示例：
  # 原始数据：03 [时间戳4字节] 01 02 09 C4 00 64 00 02 01 0A F0 00 C8 00 03 02 0B B8 01 2C 00
  # 解析结果：
  # - 充电枪数量: 3
  # - 时间戳: [具体时间]
  # - 枪1: 枪号=1, 状态=枪已连接, 电压=252.0V, 电流=1.00A, 故障码=0
  # - 枪2: 枪号=2, 状态=枪已连接, 电压=240.0V, 电流=2.00A, 故障码=0  
  # - 枪3: 枪号=3, 状态=枪锁定, 电压=184.0V, 电流=3.00A, 故障码=0
  
  # --------------------------------------------------------------------------------
  # 命令11：传感器数据 - 固定循环示例
  # --------------------------------------------------------------------------------
  # 这个命令固定包含8个传感器的数据
  11:
    - {len: 4, name: 采集时间戳, type: uint32}                           # 数据采集时间
    - {len: 1, name: 传感器组状态, type: uint8, enum: device_status}      # 整组传感器状态
    # 固定循环8次，解析8个传感器的数据
    - repeat_const: 8                                                    # 固定循环：固定8次
      fields:
        - {len: 2, name: 传感器值, type: uint16, scale: 0.1}             # 传感器数值
        - {len: 1, name: 传感器状态, type: uint8}                        # 单个传感器状态
        - {len: 1, name: 传感器类型, type: uint8}                        # 传感器类型编号
  
  # --------------------------------------------------------------------------------
  # 命令12：条件字段示例 - 根据条件解析不同字段
  # --------------------------------------------------------------------------------
  12:
    - {len: 1, name: 数据类型, type: uint8, id: data_type}              # 数据类型标识
    - {len: 4, name: 基础时间戳, type: uint32}                          # 所有类型都有的时间戳
    - {len: 2, name: 基础数据, type: uint16}                            # 所有类型都有的基础数据
    # 条件字段：只有当data_type=1时才解析扩展数据
    - {len: 4, name: 扩展数据1, type: uint32, when: "data_type == 1"}   # 仅当数据类型=1时解析
    - {len: 8, name: 详细信息, type: ascii, when: "data_type == 1"}     # 仅当数据类型=1时解析
    # 其他条件字段
    - {len: 2, name: 简化数据, type: uint16, when: "data_type == 2"}    # 仅当数据类型=2时解析
  
  # 💡 条件字段说明：
  # when: 条件表达式，支持 ==, !=, >, <, >=, <= 等比较运算符
  # 只有当条件为真时，该字段才会被解析和显示
  
  # --------------------------------------------------------------------------------
  # 命令15：BCD码和时间示例
  # --------------------------------------------------------------------------------
  15:
    - {len: 6, name: 设备编号, type: bcd6}                              # 6字节BCD码设备编号
    - {len: 7, name: 开始时间, type: cp56time2a}                        # IEC104标准时间
    - {len: 7, name: 结束时间, type: cp56time2a}                        # IEC104标准时间  
    - {len: 4, name: 电量, type: bcd4, scale: 0.01, unit: kWh}         # BCD码电量值
    - {len: 4, name: 金额, type: bcd4, scale: 0.01, unit: 元}          # BCD码金额
  
  # --------------------------------------------------------------------------------
  # 命令20：复杂嵌套循环示例
  # --------------------------------------------------------------------------------
  # 这个命令演示多层嵌套的循环结构，适用于复杂的数据组织
  20:
    - {len: 1, name: 站点数量, type: uint8, id: site_count}             # 站点总数
    - {len: 4, name: 统计时间, type: uint32}                            # 统计时间戳
    # 第一层循环：按站点数循环
    - repeat_by: site_count
      fields:
        - {len: 2, name: 站点ID, type: uint16}                          # 站点编号
        - {len: 32, name: 站点名称, type: ascii}                        # 站点名称
        - {len: 1, name: 充电桩数量, type: uint8, id: charger_count}    # 该站点的充电桩数量
        # 第二层循环：按充电桩数量循环
        - repeat_by: charger_count
          fields:
            - {len: 1, name: 充电桩编号, type: uint8}                    # 充电桩编号
            - {len: 1, name: 枪数量, type: uint8, id: gun_count_inner}  # 该充电桩的枪数量
            - {len: 1, name: 充电桩状态, type: uint8, enum: device_status} # 充电桩状态
            # 第三层循环：按枪数量循环
            - repeat_by: gun_count_inner
              fields:
                - {len: 1, name: 枪编号, type: uint8}                    # 枪编号
                - {len: 1, name: 枪状态, type: uint8, enum: gun_status}  # 枪状态
                - {len: 4, name: 累计充电量, type: uint32, scale: 0.01, unit: kWh} # 累计充电量
  
  # 💡 嵌套循环说明：
  # 可以实现任意层次的嵌套循环，每一层都可以引用前面定义的字段作为循环次数
  # id字段在同一层级内必须唯一，用于在repeat_by中引用
  
  # --------------------------------------------------------------------------------
  # 命令25：位状态解析示例
  # --------------------------------------------------------------------------------
  25:
    - {len: 4, name: 时间戳, type: uint32}                              # 状态更新时间
    - {len: 1, name: 设备状态位, type: device_status_bits}              # 使用预定义的位状态类型
    - {len: 2, name: 告警状态位, type: alarm_status_bits}               # 使用预定义的告警位状态
    - {len: 8, name: 原始状态数据, type: binary_str_8bytes}             # 原始二进制数据显示
  
  # --------------------------------------------------------------------------------
  # 命令30：完整业务场景示例 - 充电订单信息
  # --------------------------------------------------------------------------------
  30:
    - {len: 32, name: 订单号, type: ascii}                              # 订单唯一标识
    - {len: 16, name: 用户ID, type: ascii}                              # 用户标识
    - {len: 1, name: 枪号, type: uint8}                                 # 使用的充电枪
    - {len: 7, name: 开始时间, type: cp56time2a}                        # 充电开始时间
    - {len: 7, name: 结束时间, type: cp56time2a}                        # 充电结束时间
    - {len: 4, name: 充电电量, type: uint32, scale: 0.01, unit: kWh}    # 充电电量
    - {len: 4, name: 充电金额, type: uint32, scale: 0.01, unit: 元}     # 充电费用
    - {len: 1, name: 支付状态, type: uint8, enum: payment_status}       # 支付状态
    - {len: 1, name: 费率时段数, type: uint8, id: rate_period_count}    # 费率时段数量
    # 费率时段详情（变长）
    - repeat_by: rate_period_count
      fields:
        - {len: 2, name: 开始时间, type: uint16, notes: "分钟为单位从0点开始"} # 时段开始时间
        - {len: 2, name: 结束时间, type: uint16, notes: "分钟为单位从0点开始"} # 时段结束时间
        - {len: 4, name: 电价, type: uint32, scale: 0.0001, unit: 元/kWh}     # 该时段电价
        - {len: 4, name: 用电量, type: uint32, scale: 0.01, unit: kWh}        # 该时段用电量
        - {len: 4, name: 费用, type: uint32, scale: 0.01, unit: 元}          # 该时段费用
  
  # --------------------------------------------------------------------------------
  # 命令35：位字段解析示例 - 单个位标志
  # --------------------------------------------------------------------------------
  35:
    - {len: 4, name: 时间戳, type: uint32}                              # 状态更新时间
    # 单个位标志示例（最简单的bitfield用法）
    - len: 1
      name: 设备状态标志
      type: bitfield8
      bit_groups:
        - {name: "电源状态", start_bit: 0, width: 1}         # 位0：0=断电，1=通电
        - {name: "网络状态", start_bit: 1, width: 1}         # 位1：0=离线，1=在线
        - {name: "充电状态", start_bit: 2, width: 1}         # 位2：0=未充电，1=充电中
        - {name: "故障状态", start_bit: 3, width: 1}         # 位3：0=正常，1=故障
        - {name: "维护模式", start_bit: 4, width: 1}         # 位4：0=正常，1=维护
        # 位5-7 预留未使用
    
    # 多位组合示例（使用枚举）
    - len: 1  
      name: 设备控制字
      type: bitfield8
      bit_groups:
        - {name: "工作模式", start_bit: 0, width: 2, enum: device_mode}    # 位0-1：工作模式(4种)
        - {name: "告警级别", start_bit: 2, width: 2, enum: alarm_level}    # 位2-3：告警级别(4种)
        - {name: "风扇转速", start_bit: 4, width: 3}                       # 位4-6：风扇转速(0-7)
        - {name: "保留位", start_bit: 7, width: 1}                         # 位7：保留
  
  # --------------------------------------------------------------------------------  
  # 命令36：16位位字段示例
  # --------------------------------------------------------------------------------
  36:
    - {len: 4, name: 时间戳, type: uint32}
    # 16位位字段示例 - 适用于大量状态位
    - len: 2
      name: 系统状态字
      type: bitfield16
      bit_groups:
        - {name: "温度传感器1", start_bit: 0, width: 1}      # 位0
        - {name: "温度传感器2", start_bit: 1, width: 1}      # 位1
        - {name: "温度传感器3", start_bit: 2, width: 1}      # 位2
        - {name: "温度传感器4", start_bit: 3, width: 1}      # 位3
        - {name: "电压监测", start_bit: 4, width: 1}         # 位4
        - {name: "电流监测", start_bit: 5, width: 1}         # 位5
        - {name: "功率监测", start_bit: 6, width: 1}         # 位6
        - {name: "通信状态", start_bit: 7, width: 1}         # 位7
        - {name: "设备ID", start_bit: 8, width: 4}           # 位8-11：设备ID(0-15)
        - {name: "版本号", start_bit: 12, width: 4}          # 位12-15：版本号(0-15)
  
  # --------------------------------------------------------------------------------
  # 命令37：复杂位字段示例 - 扁平化输出
  # --------------------------------------------------------------------------------  
  37:
    - {len: 4, name: 时间戳, type: uint32}
    # 扁平化位字段 - 将位组直接作为独立字段输出
    - len: 2
      name: 双泵控制状态
      type: bitfield16
      flatten: true                                          # 扁平化输出
      bit_groups:
        - {name: 泵1状态, start_bit: 0, width: 4, enum: device_mode}    # 泵1状态(4位)
        - {name: 泵2状态, start_bit: 4, width: 4, enum: device_mode}    # 泵2状态(4位)
        - {name: 泵1转速, start_bit: 8, width: 4}                       # 泵1转速(4位，0-15)
        - {name: 泵2转速, start_bit: 12, width: 4}                      # 泵2转速(4位，0-15)
        
  # 💡 扁平化(flatten: true)说明：
  # - 不扁平化：输出嵌套结构，如 "双泵控制状态" -> {"泵1状态": "工作模式", "泵2状态": "待机模式"}
  # - 扁平化：输出独立字段，如 "泵1状态": "工作模式", "泵2状态": "待机模式"
  
  # --------------------------------------------------------------------------------
  # 命令38：32位位字段示例 - 大型状态字
  # --------------------------------------------------------------------------------
  38:
    - {len: 4, name: 时间戳, type: uint32}
    # 32位位字段示例 - 适用于复杂系统状态
    - len: 4
      name: 系统全状态字
      type: bitfield32
      bit_groups:
        - {name: "系统启动标志", start_bit: 0, width: 1}     # 位0
        - {name: "自检完成标志", start_bit: 1, width: 1}     # 位1
        - {name: "网络连接状态", start_bit: 2, width: 1}     # 位2
        - {name: "数据库状态", start_bit: 3, width: 1}       # 位3
        - {name: "主控模式", start_bit: 4, width: 4, enum: device_mode}     # 位4-7：主控模式
        - {name: "备用模式", start_bit: 8, width: 4, enum: device_mode}     # 位8-11：备用模式
        - {name: "系统版本", start_bit: 12, width: 8}        # 位12-19：系统版本号
        - {name: "硬件版本", start_bit: 20, width: 8}        # 位20-27：硬件版本号
        - {name: "保留字段", start_bit: 28, width: 4}        # 位28-31：保留

  # --------------------------------------------------------------------------------
  # 命令40：变长字段示例 - len_by 动态长度
  # --------------------------------------------------------------------------------
  # 当字段长度由另一个字段的值决定时使用 len_by
  40:
    - {len: 1, name: 操作类型, type: uint8, id: op_type}                      # 0=查询, 1=设置
    - {len: 4, name: 参数起始地址, type: uint32}                              # 参数地址
    - {len: 1, name: 参数个数, type: uint8}                                   # 参数个数
    - {len: 2, name: 数据字节数, type: uint16, id: data_len}                  # 后续数据的字节数
    # 变长数据字段：长度由 data_len 字段决定
    - {len: 0, name: 设置数据, type: hex, len_by: data_len, when: "op_type == 1"}  # 仅设置时有数据
  
  # 💡 len_by 说明：
  # - len: 0 表示长度不固定
  # - len_by: 指定长度来源字段的id
  # - 可以配合 when 条件使用，实现条件变长字段
  
  # --------------------------------------------------------------------------------
  # 命令41：读取剩余数据示例 - len_to_end
  # --------------------------------------------------------------------------------
  # 当需要读取报文剩余所有数据时使用 len_to_end
  41:
    - {len: 1, name: 操作类型, type: uint8, id: op_type}                      # 0=查询, 1=设置
    - {len: 4, name: 参数起始地址, type: uint32}                              # 参数地址
    - {len: 1, name: 参数个数, type: uint8}                                   # 参数个数
    - {len: 1, name: 操作结果, type: uint8}                                   # 0=成功, 1=失败
    # 读取剩余所有数据（查询响应时返回参数值）
    - {len: 0, name: 查询参数信息, type: hex, len_to_end: true, when: "op_type == 0"}
  
  # 💡 len_to_end 说明：
  # - len: 0 表示长度不固定
  # - len_to_end: true 表示读取从当前位置到报文末尾的所有数据
  # - 适用于不知道具体长度但需要读取剩余数据的场景
  
  # --------------------------------------------------------------------------------
  # 命令42：64位位字段示例 - 大量设备状态
  # --------------------------------------------------------------------------------
  42:
    - {len: 4, name: 时间戳, type: uint32}
    # 64位位字段示例 - 适用于大量设备状态位（如64个模块的在线状态）
    - len: 8
      name: 模块在线状态
      type: bitfield64
      notes: "Bit0~Bit63分别表示1~64号模块的在线状态，0=离线，1=在线"
    - len: 8
      name: 模块故障状态
      type: bitfield64
      notes: "Bit0~Bit63分别表示1~64号模块的故障状态，0=正常，1=故障"

# ==================================================================================
# 第六部分：过滤器配置 (filters) - 可选
# ==================================================================================
# 用于控制只解析特定的命令，提高解析效率和减少输出
filters:
  include_cmds: []              # 只解析指定的命令列表，如：[1, 2, 10] 表示只解析命令1,2,10
  exclude_cmds: []              # 排除指定的命令列表，如：[99, 100] 表示不解析命令99,100

# 💡 过滤器使用说明：
# - include_cmds 和 exclude_cmds 不能同时使用
# - 如果两个都为空，则解析所有命令
# - include_cmds 优先级更高，如果设置了include_cmds，exclude_cmds会被忽略

# ==================================================================================
# 配置字段详细说明
# ==================================================================================
# 
# 🔍 字段基本属性：
# ├── len: 字段长度（字节数）- 必填，设为0表示变长
# ├── name: 字段显示名称 - 必填，建议使用中文
# ├── type: 数据类型 - 必填，必须在types中定义
# ├── scale: 缩放因子 - 可选，实际值 = 原始值 × scale
# ├── offset: 偏移量 - 可选，实际值 = 原始值 + offset
# ├── unit: 单位 - 可选，仅用于显示
# ├── enum: 枚举名称 - 可选，用于值到文本的映射
# ├── id: 字段标识符 - 可选，用于repeat_by或len_by引用
# ├── when: 条件表达式 - 可选，满足条件时才解析
# ├── notes: 备注信息 - 可选，用于说明
# ├── endian: 字节序 - 可选，覆盖默认值（big/little）
# ├── bit_groups: 位组定义 - bitfield类型专用
# ├── flatten: 扁平化输出 - bitfield类型专用
# ├── len_by: 长度来源字段 - 可选，指定长度由哪个字段决定
# └── len_to_end: 读取到末尾 - 可选，true表示读取剩余所有数据
# 
# 🔄 循环控制：
# ├── repeat_by: 变长循环 - 按指定字段值或字段名循环
# └── repeat_const: 固定循环 - 固定次数循环
#
# 🎯 实用技巧：
# ├── 使用有意义的中文字段名，便于理解
# ├── 对数值字段添加单位和缩放因子
# ├── 使用枚举将数字转换为文字说明
# ├── 利用循环结构处理重复数据
# ├── 使用条件字段处理可变格式
# └── 添加备注说明特殊含义的字段
#
# ==================================================================================
# 常见问题和解决方案
# ==================================================================================
#
# ❓ 问题1：如何处理变长字符串？
# 💡 解决：使用长度字段 + 循环
# 示例：
#   - {len: 1, name: 字符串长度, type: uint8, id: str_len}
#   - {len: str_len, name: 字符串内容, type: ascii}
#
# ❓ 问题2：如何处理可选字段？
# 💡 解决：使用条件字段(when)
# 示例：
#   - {len: 1, name: 数据有效标志, type: uint8, id: data_valid}
#   - {len: 4, name: 可选数据, type: uint32, when: "data_valid == 1"}
#
# ❓ 问题3：如何处理不同版本的协议？
# 💡 解决：使用版本字段 + 条件字段
# 示例：
#   - {len: 1, name: 协议版本, type: uint8, id: version}
#   - {len: 4, name: V1字段, type: uint32, when: "version == 1"}
#   - {len: 8, name: V2字段, type: uint64, when: "version == 2"}
#
# ❓ 问题4：如何处理大端字节序？
# 💡 解决：在字段级别设置endian
# 示例：
#   - {len: 2, name: 大端数据, type: uint16, endian: big}
#
# ❓ 问题5：如何处理浮点数？
# 💡 解决：使用整数类型 + 缩放因子
# 示例：
#   - {len: 4, name: 温度值, type: uint32, scale: 0.001, unit: ℃}
#
# ❓ 问题6：如何处理复杂的状态位？
# 💡 解决：使用bitfield位字段
# 示例：
#   - len: 2
#     name: 设备状态
#     type: bitfield16
#     bit_groups:
#       - {name: "运行状态", start_bit: 0, width: 2, enum: device_mode}
#       - {name: "告警等级", start_bit: 2, width: 2, enum: alarm_level}
#       - {name: "温度值", start_bit: 4, width: 8}
#       - {name: "保留位", start_bit: 12, width: 4}
#
# ❓ 问题7：bitfield和bitset的区别？
# 💡 解答：
# - bitset: 每个位独立，适用于开关状态（如：开/关、正常/故障）
# - bitfield: 支持多位组合，适用于数值和枚举（如：模式选择、数值范围）
#
# ❓ 问题8：如何简化bitfield输出？
# 💡 解决：使用flatten扁平化
# 示例：
#   - len: 1
#     name: 双设备状态
#     type: bitfield8
#     flatten: true        # 扁平化：直接输出"设备1状态"、"设备2状态"
#     bit_groups:
#       - {name: 设备1状态, start_bit: 0, width: 4}
#       - {name: 设备2状态, start_bit: 4, width: 4}
#
# ❓ 问题9：如何处理长度由其他字段决定的变长数据？
# 💡 解决：使用 len_by 指定长度来源
# 示例：
#   - {len: 2, name: 数据长度, type: uint16, id: data_len}
#   - {len: 0, name: 变长数据, type: hex, len_by: data_len}
#
# ❓ 问题10：如何读取报文剩余的所有数据？
# 💡 解决：使用 len_to_end: true
# 示例：
#   - {len: 0, name: 剩余数据, type: hex, len_to_end: true}
#
# ❓ 问题11：如何处理64个以上设备的状态位？
# 💡 解决：使用 bitfield64 类型
# 示例：
#   - len: 8
#     name: 模块状态
#     type: bitfield64
#     notes: "Bit0~Bit63分别表示64个模块的状态"
#
# ❓ 问题12：如何在循环中使用字段名作为循环次数？
# 💡 解决：使用中文字段名作为 repeat_by 的值
# 示例：
#   - {len: 1, name: 最大模块数量, type: uint8}
#   - repeat_by: 最大模块数量
#     fields:
#       - {len: 2, name: 模块电压, type: uint16, scale: 0.1}
#
# ==================================================================================
